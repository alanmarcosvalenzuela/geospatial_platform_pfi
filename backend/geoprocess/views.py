import os
import threading
import time

from django.conf import settings
from django.core.files import File
from django.core.files.base import ContentFile
from django.http import FileResponse
from django.urls import reverse
from rest_framework import permissions, status
from rest_framework.authentication import SessionAuthentication
from rest_framework.response import Response
from rest_framework.views import APIView
from samgeo import tms_to_geotiff
from samgeo.text_sam import LangSAM
from user_api.models import AppUser

from .models import GeoProcess, Report

class UserReportsAPIView(APIView):
    permission_classes = (permissions.AllowAny,)
    def get(self, request, email, format=None):
        try:
            user = AppUser.objects.get(email=email)
            reports = Report.objects.filter(geo_process__user=user)
            serialized_reports = [
                {
                    'id': report.id,
                    'title': report.title,
                    'description': report.description,
                    'status': report.geo_process.status,
                    'file': request.build_absolute_uri(reverse('report-download', args=[report.id])) if report.file else None
                }
                for report in reports
            ]
            return Response({'user_reports': serialized_reports}, status=status.HTTP_200_OK)
        except AppUser.DoesNotExist:
            return Response({'message': 'User not found'}, status=status.HTTP_404_NOT_FOUND)


class ReportDownloadView(APIView):
    permission_classes = (permissions.AllowAny,)
    def get(self, request, report_id, format=None):
        try:
            report = Report.objects.get(pk=report_id)
            if report.file:
                response = FileResponse(report.file, as_attachment=True)
                return response
            else:
                return Response({'message': 'Report file not found'}, status=status.HTTP_404_NOT_FOUND)
        except Report.DoesNotExist:
            return Response({'message': 'Report not found'}, status=status.HTTP_404_NOT_FOUND)


class GeoProcessStatusAPIView(APIView):
    permission_classes = (permissions.AllowAny,)
    def get(self, request, geoprocess_id, format=None):
        try:
            geoprocess = GeoProcess.objects.get(pk=geoprocess_id)
            return Response({'status': geoprocess.status}, status=status.HTTP_200_OK)
        except GeoProcess.DoesNotExist:
            return Response({'message': 'GeoProcess not found'}, status=status.HTTP_404_NOT_FOUND)


class Process(APIView):
    permission_classes = (permissions.AllowAny,)
    authentication_classes = ()

    def async_function(self, geoprocess, bbox, option):

        xmin = bbox['xmin']
        ymin = bbox['ymin']
        xmax = bbox['xmax']
        ymax = bbox['ymax']
        # Create the desired format
        bbox_formatted = [xmin, ymin, xmax, ymax]

        image = "Image.tif"
        tms_to_geotiff(output=image, bbox=bbox_formatted, zoom=19, source="ESRI", overwrite=True)

        sam = LangSAM()

        if option == "arboles":
            sam.predict(image, 'tree', box_threshold=0.22, text_threshold=0.22)
            sam.show_anns(
                cmap='Greens',
                box_color='red',
                title='Segmentación Automática de Zonas Verdes',
                output='arboles.tif')
        elif option == "piletas":
            sam.predict(image, 'swimming pool', box_threshold=0.23, text_threshold=0.23)
            sam.show_anns(
                cmap='Blues',  # You can adjust the colormap as needed
                box_color='red',
                title='Automatic Segmentation of Swimming Pools',
                output='pools.tif')
        elif option == "construcciones_sam":
            sam.predict(image, 'ceiling', box_threshold=0.20, text_threshold=0.20)
            sam.show_anns(
                cmap='Greys',  # Adjust the colormap as needed
                box_color='red',
                title='Automatic Segmentation of Ceilings',
                output='ceilings.tif')
        else:
            # Handle an invalid option here if needed
            print("Funcionalidades de GEE en desarrollo")

        report_file_path = 'arboles.tif'  # Replace with the actual filename generated by sam.show_anns
        report_instance = Report.objects.create(
            geo_process=geoprocess,
            title='Segmentación Automática de Zonas Verdes',
            description='Reporte describiendo los resultados de la segmentación de espacios verdes.'
        )

        # Save the report file to the media directory
        with open(report_file_path, 'rb') as f:
            report_file_content = File(f)
            report_instance.file.save(os.path.basename(report_file_path), report_file_content)
            
        geoprocess.status = 'Finalizado'
        geoprocess.save()
        print("Función asíncrona finalizada")


    def process_async(self, bbox, option, email, geoprocess):
        self.async_function(geoprocess, bbox, option)
    

    def create_geoprocess(self, bbox, email):
        user = AppUser.objects.get(email=email)
        status_arg = 'En curso'
        geo_process_instance = GeoProcess(status=status_arg, bbox=bbox, user=user)
        return geo_process_instance

	
    def post(self, request, format=None):
        bbox = request.data.get('bbox')
        option = request.data.get('option')
        email = request.data.get('email')
        geoprocess = self.create_geoprocess(bbox, email)
        geoprocess.save()
        
        try:
            if bbox and option and email:
                print('Received bbox:', bbox)
                print('Received option:', option)
                print('Received email:', email)
                # Comienza proceso asincronico en hilo separado
                thread = threading.Thread(target=self.process_async, args=(bbox, option, email, geoprocess))
                thread.start()
                return Response({'id': geoprocess.id}, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Invalid data'}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            print("An error occurred:", str(e))
            geoprocess.status = 'Error'
            geoprocess.save()
            return Response({'message': 'An error occurred', 'id': geoprocess.id}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
